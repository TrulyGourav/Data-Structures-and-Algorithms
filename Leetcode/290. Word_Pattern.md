
# 290. Word Pattern

**Difficulty:** Easy  
**Tags:** Hashing, String, Pattern Matching, One-to-One Mapping  
**LeetCode Link:** [Word Pattern](https://leetcode.com/problems/word-pattern/)  
**Companies:** Amazon, Facebook, Google, Bloomberg

---

## 🧩 Problem Statement

Given a `pattern` and a string `s`, check if `s` follows the **same pattern**.  
Here, follow means a **full match**, where:

- Each letter in the pattern **maps to exactly one unique word** in `s`
- Each **unique word** in `s` maps to exactly one **letter** in the pattern

In short, there should be a **bijective (one-to-one and onto)** mapping between pattern characters and words in `s`.

---

### 🧪 Example 1:
```
Input: pattern = "abba", s = "dog cat cat dog"
Output: true
Explanation: 'a' → "dog", 'b' → "cat"
```

### ❌ Example 2:
```
Input: pattern = "abba", s = "dog cat cat fish"
Output: false
```

### ❌ Example 3:
```
Input: pattern = "aaaa", s = "dog cat cat dog"
Output: false
```

---

## ✅ Constraints

- `1 <= pattern.length <= 300`
- `1 <= s.length <= 3000`
- Only lowercase English letters and spaces, no trailing/leading spaces
- Words are separated by a **single space**

---

## 🔍 Intuition (🔆 Highlight This While Revising)

If two characters map to the same word (or vice versa), the pattern fails.  
We need a **bijective** mapping:  
> Every `char` maps to exactly **one** `word`, and every `word` maps to **one** `char`.

Instead of two maps, we can **map each `char` and `word` to its latest index**, and if they ever mismatch at the same position, it means the mapping isn't consistent.

---

## 🧠 Conceptual Understanding

We maintain:
- `Map<Character, Integer> charToIndex`
- `Map<String, Integer> wordToIndex`

As we iterate:
- Store the latest index for each character and each word.
- If at any index `i`, the previous index of `pattern[i]` and `word[i]` are **not equal**, it's an invalid mapping.

This ensures:
- One-to-one mapping
- Injective + Surjective → Bijective

---

## 🧮 Time and Space Complexity

| Complexity | Value             |
|------------|------------------|
| Time       | `O(n)` where `n` is number of words in `s` or length of `pattern` |
| Space      | `O(n)` for storing mappings in two HashMaps |

---

## 🌳 Graphical Mapping (Centered Test Case)

Let’s walk through this:

```
pattern = "abba"
words   = ["dog", "cat", "cat", "dog"]

Mapping steps:
i=0 → 'a' ↔ "dog"     → Map: {a:0}, {dog:0}
i=1 → 'b' ↔ "cat"     → Map: {b:1}, {cat:1}
i=2 → 'b' ↔ "cat"     → already matched correctly
i=3 → 'a' ↔ "dog"     → already matched correctly ✅
```

---

## ✅ Java Code (Current Solution)

```java
class Solution {
  public boolean wordPattern(String pattern, String str) {
    String[] words = str.split(" ");
    if (words.length != pattern.length())
      return false;

    Map<Character, Integer> charToIndex = new HashMap<>();
    Map<String, Integer> stringToIndex = new HashMap<>();

    for (int i = 0; i < pattern.length(); ++i)
      if (charToIndex.put(pattern.charAt(i), i) != stringToIndex.put(words[i], i))
        return false;

    return true;
  }
}
```

---

## 🧭 Other Approaches

| Approach                    | Time     | Space    | Comment                      |
|----------------------------|----------|----------|------------------------------|
| Brute-force with nested loop | O(n²)  | O(1)     | Compare substrings manually |
| Two HashMaps (bijective check) | O(n) | O(n)     | Separate char→word & word→char mapping |
| 🔥 **Current (Index Mapping)** | O(n) | O(n)     | Most elegant and short ✅ |

---

## 🔗 Related & Subproblems

| Problem                                     | Link |
|---------------------------------------------|------|
| 205. Isomorphic Strings                     | [LeetCode #205](https://leetcode.com/problems/isomorphic-strings) |
| 291. Word Pattern II (Backtracking)         | [LeetCode #291](https://leetcode.com/problems/word-pattern-ii) |
| 1. Two Sum                                  | [LeetCode #1](https://leetcode.com/problems/two-sum/) *(hash mapping idea)* |
| 890. Find and Replace Pattern               | [LeetCode #890](https://leetcode.com/problems/find-and-replace-pattern/) |

---

## 🧠 Pattern Recognition

This is a **bijection** problem. Look out for:
- Mapping relationships (char ↔ word, digit ↔ string, etc.)
- Questions that involve **structure** similarity (e.g. isomorphic strings)
- Problems involving **injective + surjective** mappings → use **two maps or indexed mapping**

---

## 🧠 Memory Tip (🔥 To Never Forget This)

> Imagine assigning **name tags** at a party.
>  
> One person (pattern char) can only wear one name tag (word), and each tag must belong to one person only.  
> If the name tags get swapped or reused, you know something’s wrong!  
>  
> This visualization helps you remember the **one-to-one uniqueness** principle.

---

📚 **Keep practicing** such mapping-based problems. These appear frequently in **interviews** under **String, HashMap, and Pattern Matching** categories.
