# 1143. Longest Common Subsequence

## 🧾 Problem Statement

**Leetcode #1143** — Medium

> Given two strings `text1` and `text2`, return the **length of their longest common subsequence**. If no such subsequence exists, return 0.  
>  
> A subsequence of a string is a new string generated by deleting **some characters (can be none)** without changing the relative order of remaining characters.  
>  
> Example:  
> - `"ace"` is a subsequence of `"abcde"`.

---

## 💡 Intuition (🔥 Very Important)

To find the longest common subsequence (LCS), we ask:
- "How many characters from both strings can be kept in **relative order**?"

💥 The trick:  
We break the problem into smaller subproblems —  
**"What's the LCS of the first `i` characters of `text1` and first `j` characters of `text2`?"**

If characters at `i-1` and `j-1` are equal → **include that in LCS.**  
Else → **explore both possibilities:**
- exclude from text1
- exclude from text2  
Take the **max** of both.

This naturally screams **Dynamic Programming**!

---

## 🧠 Conceptual Understanding

- We use a **2D DP table `dp[i][j]`** to store LCS length for prefixes `text1[0...i-1]` and `text2[0...j-1]`.
- We **build up the solution bottom-up**, ensuring subproblems are solved first.
- Final answer is stored in `dp[m][n]`.

### 📊 Example Dry-Run

For `text1 = "abcde"` and `text2 = "ace"`:

|     |  "" |  a |  c |  e |
|-----|-----|----|----|----|
| ""  |  0  | 0  | 0  | 0  |
| a   |  0  | 1  | 1  | 1  |
| b   |  0  | 1  | 1  | 1  |
| c   |  0  | 1  | 2  | 2  |
| d   |  0  | 1  | 2  | 2  |
| e   |  0  | 1  | 2  | 3  |

Answer = 3 (which is `"ace"`)

---

## 🧭 Approach: Dynamic Programming (Tabulation)

### Steps:
1. Create a DP table `dp[m+1][n+1]`, where `m = len(text1)`, `n = len(text2)`
2. Iterate `i = 1...m` and `j = 1...n`
3. If `text1[i-1] == text2[j-1]`:  
   `dp[i][j] = dp[i-1][j-1] + 1`
4. Else:  
   `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
5. Return `dp[m][n]`

---

## 🧠 Code Solution (Java)

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
}
```

---

## ⏱ Time & Space Complexity

| Metric              | Value               |
|---------------------|---------------------|
| Time Complexity     | `O(m * n)`          |
| Space Complexity    | `O(m * n)`          |

Can be optimized to `O(min(m, n))` using **2-row rolling array**.

---

## 🧮 Other Approaches & Comparisons

| Approach Type               | Description                                                                 | Time     | Space    | Used? |
|----------------------------|-----------------------------------------------------------------------------|----------|----------|-------|
| Brute Force (Recursion)     | Try all subsequences of `text1`, check in `text2`                          | `O(2^m)` | `O(m)`   | ❌     |
| Recursive with Memoization  | Top-down + cache to avoid re-computation                                   | `O(m*n)` | `O(m*n)` | ❌     |
| ✅ Bottom-up Tabulation      | Build table from base cases, iterative                                      | `O(m*n)` | `O(m*n)` | ✅     |
| Space Optimized DP          | Use only 2 rows instead of full DP table                                    | `O(m*n)` | `O(min(m,n))` | 🔁 Optional |

---

## 🔍 Pattern & Related Problems

**Pattern:** Dynamic Programming – **"2D Matrix DP"**, **"Subsequence Problems"**

**Similar Problems:**
1. [Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)
2. [Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)
3. [Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/)

---

## 🧠 Tip to Remember This Forever (Sticky 💡)

> **Imagine aligning two ribbons (`text1` and `text2`) and sewing only when colors match.**  
> Each match adds 1 to the sewn section.  
> If no match at current position? Try skipping one color from either ribbon to see which gives a longer sewn segment.

🔁 This helps you visualize the choice:
- Keep both ends (if they match)
- Skip from one side and retry

**Memory Tagline:**  
> 🧵 *"If colors match, sew! Else skip and try again."*